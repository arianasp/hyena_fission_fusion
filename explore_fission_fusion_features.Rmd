---
title: "From fission-fusion events to social structure"
output: html_document
---

In the fission-fusion societies of spotted hyenas, all social interactions 
arise from and are constrained by the coming together or dissolution of individuals. 

Consequently, dyadic fission-fusion events can be considered
the atomic unit of social structure in these societies.  

In this project we want to understand how the mechanics of fission-fusion events 
scale up to broader patterns in social relationships and social structure.    

**Goals:**  
1. Methodological framework for identifying and measuring fission-fusion events  
2. Taxonomy of basic types of fission-fusion events  
3. Use this taxonomy to better understand social structure  

![](https://static.wixstatic.com/media/a3e3e7_bc533d1dfdfc459fa3950b84700830e4~mv2_d_3727_2618_s_4_2.jpg/v1/crop/x_193,y_111,w_3297,h_2366/fill/w_560,h_394,al_c,q_80,usm_0.66_1.00_0.01/a3e3e7_bc533d1dfdfc459fa3950b84700830e4~mv2_d_3727_2618_s_4_2.webp)

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(knitr)
library(dichromat)
library(plotly)
library(scales)
library(fields)
library(lubridate)
library(gifski)
library(textclean)

# name <- readline(prompt = "Enter name:")
# 
# if(grepl('a|A', name)){
    basedir <- '~/Dropbox/hyenas/hyena_fission_fusion/' # <-- CHANGE TO THE MAIN PROJECT FOLDER
    codedir <- '~/Dropbox/code_ari/hyena_fission_fusion/' # <-- CHANGE TO THE DIRECTORY WHERE CODE REPOSITORY IS
# }else if(grepl('e|E', name)){
 #basedir <- 'C:/Users/strau/Dropbox/hyena_fission_fusion/' # <-- CHANGE TO THE MAIN PROJECT FOLDER
 #codedir <- 'C:/Users/strau/Dropbox/Documents/Research/Partial_projects/hyena_fission_fusion/' # <-- CHANGE TO THE DIRECTORY WHERE CODE REPOSITORY IS
# }else{
#   cat('Name not recognized')
# }

#SUBDIRECTORIES
datadir <- paste(basedir, 'data/raw', sep = '')
processeddir <- paste(basedir, 'data/processed', sep = '') #this is where the output will be saved (the fission fusion events RData file)

#FUNCTIONS
source(paste0(codedir,'/hyena_functions.R'))

#PROCESSED DATA
load(file = paste0(processeddir,'/fission_fusion_features.RData'))
load(file = paste0(processeddir,'/fission_fusion_events.RData'))
load(file = paste0(datadir,'/hyena_xy_level1.RData'))
load(file = paste0(datadir,'/hyena_timestamps.Rdata'))
load(file = paste0(datadir,'/hyena_ids.RData'))

#Read in den data
den.file <- paste0(datadir, '/hyena_isolate_dens.csv')
den.names <- c('DAVE D','RBEND D','RES M D1','DICK D')
known.locs <- read.csv(den.file,stringsAsFactors=F)
eastsNorths <- latlon.to.utm(cbind(known.locs$lon,known.locs$lat),southern_hemisphere=T,utm.zone=36)
known.locs$east <- eastsNorths[,1]
known.locs$north <- eastsNorths[,2]
den.locs <- known.locs[which(known.locs$name %in% den.names),]
den.locs$name <- as.character(den.locs$name)

good.idxs <- which(events$start.exact & events$end.exact)


```

# What is a fission-fusion event?

Fission-fusion events are identified as cases where two individuals get within 100m of each other. 
Once an event is identified, data are collected for the entire duration of the period in which 
they are within 200m of each other. 


**FIGURE**

```{r general exploration, echo = FALSE, fig.show= 'hold', out.width = "50%"}


examples <- good.idxs[45:49]

par(mfrow = c(1,1))
plot_events(indices = examples, events = events, xs, ys, phase.col = FALSE)
```

# Some basic exploration of fission-fusion events

Overall, there are `r nrow(events)` fission-fusion events total in our dataset. Of these, `r length(good.idxs)` have defined starting and ending points. We will focus on these 'complete' events for the purposes of this initial analysis. 

First, let's get some basic info. **How long do these events tend to be?**

```{r duration distribution, echo = FALSE}

hist((events$t.end[good.idxs] - events$t.start[good.idxs])/60/60, breaks = 100, main = 'Duration of fission-fusion events', xlab = 'Time (hours)', ylab = 'Frequency', col = 'gray')

```

**How far do two hyenas typically travel during a fission-fusion event?** The plot below shows the distribution of displacements for one of the hyenas during the entire event.

```{r displacement distribution, echo = FALSE}

#get total displacement of i during the event
dx <- xs[cbind(events$i[good.idxs], events$t.end[good.idxs])] -  xs[cbind(events$i[good.idxs], events$t.start[good.idxs])]
dy <- ys[cbind(events$i[good.idxs], events$t.end[good.idxs])] -  ys[cbind(events$i[good.idxs], events$t.start[good.idxs])]
ds <- sqrt(dx^2 + dy^2)

hist(ds, breaks = 100, main = 'Displacement during fission-fusion events', xlab = 'Displacement (m)', ylab = 'Frequency', col = 'gray')

```

H**ow close do hyenas normally get to one another during fission-fusion events?**

```{r closest approach, echo = FALSE}

hist(events$closest.app[good.idxs], breaks = 20, main = 'Closest approach during fission-fusion events', xlab = 'Displacement (m)', ylab = 'Frequency', col = 'gray')

```

**Where do fission-fusion events occur? How often do they occur at dens?**

Let's look at the distance to the closest den at the start of events (for the hyena closest to the den):

```{r distance from den, echo = FALSE}

dist.to.den.start <- dist.to.den.end <- matrix(nrow = nrow(events), ncol = nrow(den.locs))
dist.den.all <- array(dim = c(nrow(xs), ncol(xs), nrow(den.locs)))
for(i in 1:nrow(den.locs)){
  x.d <- den.locs$east[i]
  y.d <- den.locs$north[i]
  
  #start of event
  dxi <- xs[cbind(events$i, events$t.start)] - x.d
  dyi <- ys[cbind(events$i, events$t.start)] - y.d
  ddi <- sqrt(dxi^2 + dyi^2)
  dxj <- xs[cbind(events$j, events$t.start)] - x.d
  dyj <- ys[cbind(events$j, events$t.start)] - y.d
  ddj <- sqrt(dxj^2 + dyj^2)
  dist.to.den.start[,i] <- apply(X = cbind(ddi,ddj), MARGIN = 1, FUN = min, na.rm=T)
  
  #end of event
  dxi <- xs[cbind(events$i, events$t.end)] - x.d
  dyi <- ys[cbind(events$i, events$t.end)] - y.d
  ddi <- sqrt(dxi^2 + dyi^2)
  dxj <- xs[cbind(events$j, events$t.end)] - x.d
  dyj <- ys[cbind(events$j, events$t.end)] - y.d
  ddj <- sqrt(dxj^2 + dyj^2)
  dist.to.den.end[,i] <- apply(X = cbind(ddi,ddj), MARGIN = 1, FUN = min, na.rm=T)
  
  #over all times
  dx.all <- xs - x.d
  dy.all <- ys - y.d
  dist.den.all[,,i] <- sqrt(dx.all^2 + dy.all^2)
  
}

#min dist to den at start and end of events
min.dist.to.den.start <- apply(dist.to.den.start, 1, min, na.rm=T)
min.dist.to.den.end <- apply(dist.to.den.end, 1, min, na.rm=T)

#store in table
events$dist.den.start <- min.dist.to.den.start
events$dist.den.end <- min.dist.to.den.end

#min distance to den overall
idxs.to.use <- seq(1, ncol(xs), by = 60)
idxs.to.use <- idxs.to.use[which(colSums(is.na(xs[,idxs.to.use])) == 0)]
min.dist.to.den.all <- apply(dist.den.all[,idxs.to.use,], c(1,2), function(x){return(min(x,na.rm=T))})

par(mfrow=c(1,3))

hist(min.dist.to.den.start, breaks = seq(0,6000,100), main = 'Dist to closest den at event start', xlab = 'Distance (m)', ylab = 'Probability density', col = 'gray', freq=F, ylim = c(0,.007))

hist(min.dist.to.den.end, breaks = seq(0,6000,100), main = 'Dist to closest den at event end', xlab = 'Distance (m)', ylab = 'Probability density', col = 'gray', freq=F, ylim = c(0,.007))

#overall distance to den across all data
hist(min.dist.to.den.all, breaks = seq(0,20000,100), xlim = c(0,6000), main = 'Dist to closest den over all data', xlab = 'Distance (m)', ylab = 'Probability density', col = 'gray',freq=F, ylim = c(0,.007))

```

To simplify, we can just ask whether hyenas are at the den or not (less than 200 m from nearest den).

```{r at den or not, echo = FALSE}
R.den <- 200

at.den.start <- mean(min.dist.to.den.start < R.den)
at.den.end <- mean(min.dist.to.den.end < R.den)
at.den.all <- mean(min.dist.to.den.all < R.den)

```

Overall, we find that fission-fusion events start at the den `r round(at.den.start*100)`% of the time and end at the den `r round(at.den.end*100)`% of the time. This can be compared to the total amount of time that hyenas spend close to dens, which is `r round(at.den.all*100)`%. As expected, fission-fusion events occur a large proportion of the time at dens, but not always. If we expand our definition of 'at the den' to include up to 500 m away from the den, then these numbers change to `r round(mean(min.dist.to.den.start < 500)*100)`% at event start, `r round(mean(min.dist.to.den.end < 500)*100)`% at event end, and `r round(mean(min.dist.to.den.all < 500)*100)`% over all the data. 

**What time of day do fission-fusion events occur?**

```{r fission-fusion time of day, echo = FALSE}

hist(hour(timestamps[events$t.start]+3*60*60), breaks = seq(0,24,1), xlab = 'Time of day (hour)', ylab = 'Frequency', col = rainbow(24), main = 'Time of day of fission-fusion event starts')
hist(hour(timestamps[events$t.end]+3*60*60), breaks = seq(0,24,1), xlab = 'Time of day (hour)', ylab = 'Frequency', col = rainbow(24), main = 'Time of day of fission-fusion event ends')

```

**Who takes part in fission-fusion events, and how often?**

```{r number of events per dyad, echo = FALSE}

n.events.per.dyad <- tot.dur.per.dyad <- dyad.tracked <- matrix(nrow=nrow(xs), ncol = nrow(xs))
for(i in 1:(nrow(xs)-1)){
  for(j in (i+1):nrow(xs)){
    n.events.per.dyad[i,j] <- length(which(events$i == i & events$j==j))
    tot.dur.per.dyad[i,j] <- sum((events$t.end - events$t.start)[which(events$i == i & events$j==j)])
    dyad.tracked[i,j] <- sum(!is.na(xs[i,] & !is.na(xs[j,])))
  }
}

image.plot(n.events.per.dyad, xaxt = 'n', yaxt = 'n', col = viridis(256))
axis(side = 1, at = seq(0,1, length.out = nrow(hyena.ids)), hyena.ids$name)
axis(side = 2, at = seq(0,1, length.out = nrow(hyena.ids)), hyena.ids$name)
title(main = 'Number of events per dyad')

image.plot(tot.dur.per.dyad / dyad.tracked * 100, xaxt = 'n', yaxt = 'n', col = viridis(256))
axis(side = 1, at = seq(0,1, length.out = nrow(hyena.ids)), hyena.ids$name)
axis(side = 2, at = seq(0,1, length.out = nrow(hyena.ids)), hyena.ids$name)
title(main = 'Percentage of time tracked spent together per dyad')

```

Clearly there is some variation, which likely reflects a combination of social preferences and ranging patterns / shared den use. We can get into this more later.


# Measuring fission fusion events

### Canonical shape of fission-fusion events

A fundamental measure of dyadic fission fusion events is the distance between
the two individuals ("dyadic distance"). 

Dyadic distance during fission-fusion events has a canonical structure:  
1. There is first a decrease in the dyadic distance (as the two hyenas get closer together; "fusion phase")  
2. then a relatively stable period where the hyenas spend time close together ("together phase")  
3. followed by an increase in the dyadic distance as they part ways ("fission" phase).   

<!-- Our goal is to characterize fission-fusion events and categorize them into a set -->
<!-- of biologically meaningful categories. To do this, we decided to start by looking -->
<!-- at the distance between the pair of individuals over time during each event.  -->

Based on this idea, we decided to fit all fission-fusion events to this canonical 
structure using a 3-part piecewise function. Although the fit isn't always perfect, this approach does
do a reasonable job at capturing the structure of the events.

This allows fission-fusion events to be decomposed into three phases: fission phase, fusion phase, together phase. 

Here are some plots of example events with dyadic distance in black and the fitted 
phases in red. 

```{r plot a single event, echo = FALSE}
par(mfrow = c(1,2))
plot_events(indices = examples[1], events, xs, ys, phase.col = FALSE)
plot_canonical_shape(rows = examples[1], dyad.dists = dyad.dists, events)

plot_events(indices = examples[2], events, xs, ys, phase.col = FALSE)
plot_canonical_shape(rows = examples[2], dyad.dists, events)

plot_events(indices = examples[3], events, xs, ys, phase.col = FALSE)
plot_canonical_shape(rows = examples[3], dyad.dists, events)
```


## Detecting variation in phases of fission-fusion events

We identified two primary variables that capture a lot of variability within phases
of fission-fusion events: 

**Displacement of individuals:** How much did each individual move during the phase?  
**Angle between heading of individuals:** What is the angle between the headings of the two individuals?  


#### Displacement of individuals  

We first looked at the displacement one individual vs the other individual in each of the phases separately.  

Especially in the fission and fusion phases, we see two clear clusters where one 
individual is stationary and the other is moving. We also see a large scattering 
of points representing cases where both individuals are moving substantially. 

```{r plot distance travelled for each individual, echo = FALSE, fig.show = 'hold', out.width = "50%"}

plot(events$disp.fusion.i[good.idxs], events$disp.fusion.j[good.idxs], xlim = c(0,700), ylim = c(0, 700),
     xlab = 'Distance travelled by A', pch = 19, col = scales::alpha('black', 0.3), cex = 0.8, ylab = 'Distance travelled by B', main = 'Fusion phase')

plot(events$disp.together.i[good.idxs], events$disp.together.j[good.idxs], xlim = c(0,700), ylim = c(0, 700),
     xlab = 'Distance travelled by A', pch = 19, col = scales::alpha('black', 0.3), cex = 0.8, ylab = 'Distance travelled by B', main = 'Together phase')

plot(events$disp.fission.i[good.idxs], events$disp.fission.j[good.idxs], xlim = c(0,700), ylim = c(0, 700),
     xlab = 'Distance travelled by A', pch = 19, col = scales::alpha('black', 0.3), cex = 0.8, ylab = 'Distance travelled by B', main = 'Fission phase')


```

#### Angle between heading of individuals

We calculated the angle between the two individuals trajectories, calculated over
the entire phase.  

Including the angle in the plots shows that the angle further resolves some different
types of fission-fusion events, especially in the fission and fusion phases.

```{r plot angle between trajectories of two individuals, echo = FALSE}

min.move <- 50

both.move.fusion <- which(events$disp.fusion.i >= min.move & events$disp.fusion.j >= min.move)
both.move.together <- which(events$disp.together.i >= min.move & events$disp.together.j >= min.move)
both.move.fission <- which(events$disp.fission.i >= min.move & events$disp.fission.j >= min.move)

# hist(events$angle.fusion[both.move.fusion], main = 'Angles during fusion', breaks = 50, xlab = 'Angle (radians)')
# hist(events$angle.together[both.move.together], main = 'Angles during together', breaks = 50, xlab = 'Angle (radians)')
# hist(events$angle.fission[both.move.fission], main = 'Angles during fission', breaks = 50, xlab = 'Angle (radians)')
# 


pal <- colorRampPalette(c('blue', 'black', 'goldenrod1'))
cols <- pal(320)

# Same plots as before but colored by angle
plot(events$disp.fusion.i[good.idxs], events$disp.fusion.j[good.idxs], xlim = c(0,700), ylim = c(0, 700),
     xlab = 'Distance travelled by A', pch = 19, cex = 0.8, ylab = 'Distance travelled by B', main = 'Fusion phase',
     col = alpha(cols[ceiling(events$angle.fusion[good.idxs] * 100)], 0.7))

p <- par()$usr
text(x = p[1] + 0.15*(p[2]-p[1]), y = p[4]- 0.1*(p[4]-p[3]), 'heading unaligned', col = cols[314], adj = 0)
text(x = p[1] + 0.15*(p[2]-p[1]), y = p[4]- 0.15*(p[4]-p[3]), 'heading aligned', col = cols[1], adj = 0)

plot(events$disp.together.i[good.idxs], events$disp.together.j[good.idxs],
     xlab = 'Distance travelled by A', pch = 19, cex = 0.8, ylab = 'Distance travelled by B', main = 'Together phase',
     col = alpha(cols[ceiling(events$angle.together[good.idxs] * 100)], 0.7))
p <- par()$usr
text(x = p[1] + 0.15*(p[2]-p[1]), y = p[4]- 0.1*(p[4]-p[3]), 'heading unaligned', col = cols[314], adj = 0)
text(x = p[1] + 0.15*(p[2]-p[1]), y = p[4]- 0.15*(p[4]-p[3]), 'heading aligned', col = cols[1], adj = 0)

plot(events$disp.together.i[good.idxs], events$disp.together.j[good.idxs], xlim = c(0,200), ylim = c(0,200),
     xlab = 'Distance travelled by A', pch = 19, cex = 0.8, ylab = 'Distance travelled by B', main = 'Together phase (zoomed in)',
     col = alpha(cols[ceiling(events$angle.together[good.idxs] * 100)], 0.7))
p <- par()$usr
text(x = p[1] + 0.15*(p[2]-p[1]), y = p[4]- 0.1*(p[4]-p[3]), 'heading unaligned', col = cols[314], adj = 0)
text(x = p[1] + 0.15*(p[2]-p[1]), y = p[4]- 0.15*(p[4]-p[3]), 'heading aligned', col = cols[1], adj = 0)

plot(events$disp.fission.i[good.idxs], events$disp.fission.j[good.idxs], xlim = c(0,700), ylim = c(0, 700),
     xlab = 'Distance travelled by A', pch = 19, cex = 0.8, ylab = 'Distance travelled by B', main = 'Fission phase',
     col = alpha(cols[ceiling(events$angle.fission[good.idxs] * 100)], 0.7))
p <- par()$usr
text(x = p[1] + 0.15*(p[2]-p[1]), y = p[4]- 0.1*(p[4]-p[3]), 'heading unaligned', col = cols[314], adj = 0)
text(x = p[1] + 0.15*(p[2]-p[1]), y = p[4]- 0.15*(p[4]-p[3]), 'heading aligned', col = cols[1], adj = 0)

```

```{r phases to categories, echo = FALSE}
#thresholds
move.thresh <- 5
ang.thresh <- pi/2

#defining clusters - fusion
fusion.stay.move.idxs <- which(events$disp.fusion.i <= move.thresh)
fusion.move.stay.idxs <- which(events$disp.fusion.j <= move.thresh)
fusion.move.move.bigang.idxs <- which(events$disp.fusion.i > move.thresh & events$disp.fusion.j > move.thresh & events$angle.fusion > ang.thresh)
fusion.move.move.smallang.idxs <- which(events$disp.fusion.i > move.thresh & events$disp.fusion.j > move.thresh & events$angle.fusion <= ang.thresh)

#defining clusters - together
together.travel.thresh <- 200
together.local.idxs <- which(events$disp.together.i <= together.travel.thresh | events$disp.together.j <= together.travel.thresh)
together.travel.idxs <- which(events$disp.together.i > together.travel.thresh & events$disp.together.j > together.travel.thresh)

#defining clusters - fission
fission.stay.move.idxs <- which(events$disp.fission.i <= move.thresh)
fission.move.stay.idxs <- which(events$disp.fission.j <= move.thresh)
fission.move.move.bigang.idxs <- which(events$disp.fission.i > move.thresh & events$disp.fission.j > move.thresh & events$angle.fission > ang.thresh)
fission.move.move.smallang.idxs <- which(events$disp.fission.i > move.thresh & events$disp.fission.j > move.thresh & events$angle.fission <= ang.thresh)

#store clusters in events data frame
events$fusion.type <- events$together.type <- events$fission.type <- NA
events$fusion.type[fusion.stay.move.idxs] <- 'fusion.stay.move'
events$fusion.type[fusion.move.stay.idxs] <- 'fusion.move.stay'
events$fusion.type[fusion.move.move.bigang.idxs] <- 'fusion.move.move.unaligned'
events$fusion.type[fusion.move.move.smallang.idxs] <- 'fusion.move.move.aligned'
events$together.type[together.local.idxs] <- 'together.local'
events$together.type[together.travel.idxs] <- 'together.travel'
events$fission.type[fission.stay.move.idxs] <- 'fission.stay.move'
events$fission.type[fission.move.stay.idxs] <- 'fission.move.stay'
events$fission.type[fission.move.move.bigang.idxs] <- 'fission.move.move.unaligned'
events$fission.type[fission.move.move.smallang.idxs] <- 'fission.move.move.aligned'

#look at what types emerge
complete.events <- which(!(is.na(events$fusion.type) | is.na(events$together.type) | is.na(events$fission.type)))
events$event.type <- paste(events$fusion.type, events$together.type, events$fission.type, sep = '__')

```

## Taxonomy of fission-fusion events using phase measurements

Next we broke phases into a set of discrete categories.

For all 3 phases, we divided events into categories based on the movement of individuals.  

We chose a **movement threshold** of `r move.thresh`m to classify each individual as moving or not moving. 
We chose an **angle threshold** of `r round(ang.thresh/pi * 180, 2)` degrees to classify individuals as having
aligned or opposite movement trajectories.

We identified the following categories: 

**Fusion phase (4)**
1. Individual A moving, Individual B stationary    
2. Individual A stationary, Individual B moving  
3. Both moving, trajectories aligned  
4. Both moving, trajectories unaligned  

**Together phase (4)**
1. Local (individuals stayed within 200 m)  
2. Traveling (both individuals had a displacement > 200 m)  

**Fission phase (4)**
1. Individual A moving, Individual B stationary  
2. Individual A stationary, Individual B moving  
3. Both moving, trajectories aligned  
4. Both moving, trajectories unaligned  


```{r plotting phase categories, echo = FALSE, message = FALSE, warning=FALSE}

fusion.cols <- c('#33658A', '#86BBD8', '#758E4F', '#F26419')
together.cols <- c('#210124', '#750D37', '#9CD3AE', '#0C4634')


#3d plot
aX <- list(title = "Distance travelled by A (m)", range = c(0,700))
aY <- list(title = "Distance travelled by B (m)", range = c(0,700))
aZ <- list(title = 'Angle (degrees)', range = c(0, 210))
plot_ly(x = events$disp.together.i[good.idxs], y = events$disp.together.j[good.idxs], z = events$angle.together[good.idxs]*180/pi, type = 'scatter3d', mode = 'markers', size = 0.5,
        color = as.factor(events$together.type[good.idxs]), colors = together.cols) %>%
   layout(scene = list(xaxis = aX, yaxis = aY, zaxis = aZ, dragmode="turntable"))


aX <- list(title = "Distance travelled by A (m)", range = c(0,700))
aY <- list(title = "Distance travelled by B (m)", range = c(0,700))
aZ <- list(title = 'Angle (degrees)', range = c(0, 210))
plot_ly(x = events$disp.fusion.i[good.idxs], y = events$disp.fusion.j[good.idxs], z = events$angle.fusion[good.idxs]*180/pi, type = 'scatter3d', mode = 'markers', size = 0.5,
        color = as.factor(events$fusion.type[good.idxs]), colors = fusion.cols) %>%
   layout(scene = list(xaxis = aX, yaxis = aY, zaxis = aZ, dragmode="turntable"))

#2d plot
cols <- c('red','blue','green','black','gray')
fusion.event.types <- unique(events$fusion.type)
plot(events$disp.fusion.i[good.idxs], events$disp.fusion.j[good.idxs], xlim = c(0,700), ylim = c(0, 700),
     xlab = 'Distance travelled by A', pch = 19, cex = 0.8, ylab = 'Distance travelled by B', main = 'Fusion phase',
     col = fusion.cols[as.factor(events$fusion.type[good.idxs])])

```

Summarizing how often we find fusions, together phases, and fissions of each type, we can have a look at the frequencies of each type. It's worth nothing that the "stay.move" and "move.stay" categories in the fusion and fission phases are essentially the same, however let's keep them separate now since the order matters when combining the phases into sequences, as we'll do next.

```{r phase frequency tables, echo = FALSE}
kable(table(events$fusion.type[good.idxs]), col.names = c('Fusion phase type','Frequency'))
kable(table(events$together.type[good.idxs]), col.names = c('Together phase type','Frequency'))
kable(table(events$fission.type[good.idxs]), col.names = c('Fission phase type','Frequency'))

```

## Combining phase types to classify entire events

Now that we've classified the phases into types, we can look at entire fusion-together-fision sequences and classify those into types. These classifications (ideally) give a very simple category for each fission-fusion interaction. Of course, we know this is a drastic simplification, and there are many more aspects of these interactions that would be good to explore in the future. But for now, let's categorize them into "event types" simply by connecting the phases.

Note here that there are a few equivalent event types that we need to combine - for instance fusion.stay.move__together.move.stay__fission.move.stay is equivalent to fusion.move.stay__together.stay.move__fission.stay.move, just with the identities of the individuals swapped. To avoid confusion, let's call the non-symmetrized version the "event.type" and the one in which the symmetries have been collapsed the "event.type.collapsed"

```{r collapse symmetric events, echo = FALSE}

#create a column for the collapsed event type (collapsing the symmetry of move.stay and stay.move)
events$event.type.collapsed <- events$event.type

#fusion move.stay --> fusion.stay.move in cases where fission has a mover and a stayer
fusion.move.stay.idxs <- which(events$fusion.type == 'fusion.move.stay') #get indexes where fusion type is move.stay
fission.asymmetric.idxs <- which(grepl('move',events$fission.type) & grepl('stay', events$fission.type)) #get indexes where fusion type is stay.move or move.stay
idxs.to.swap <- intersect(fusion.move.stay.idxs, fission.asymmetric.idxs)
events$event.type.collapsed[idxs.to.swap] <- textclean::swap(events$event.type[idxs.to.swap], 'move','stay')

#fusion.move.stay --> fusion.stay.move in cases where fission has only movers
fission.move.move.idxs <- which(!grepl('stay', events$fission.type))
idxs.to.change <- intersect(fusion.move.stay.idxs, fission.move.move.idxs)
events$event.type.collapsed[idxs.to.change] <- sub('fusion.move.stay', 'fusion.stay.move', events$event.type[idxs.to.change])

#fission.move.stay --> fission.stay.move in cases where fusion has only movers
fission.move.stay.idxs <- which(events$fission.type == 'fission.move.stay') #get indexes where fission type is move.stay
fusion.move.move.idxs <- which(!grepl('stay', events$fusion.type))
idxs.to.change <- intersect(fission.move.stay.idxs, fusion.move.move.idxs)
events$event.type.collapsed[idxs.to.change] <- sub('fission.move.stay', 'fission.stay.move', events$event.type[idxs.to.change])

```

Doing this gives us a "taxonomy" of event types. What kinds of events do we commonly see?

```{r code to plot examples of an event of a certain rank, echo = FALSE}

event.types.by.freq <- sort(table(events$event.type.collapsed[complete.events]), decreasing = T)

kable(event.types.by.freq, col.names = c('Event Type','Frequency'))

plot_events_of_rank <- function(event.rank, event.types.by.freq = event.types.by.freq, events = events, xs = xs, ys = ys){

  idxs.event.type <- which(events$event.type == names(event.types.by.freq[event.rank])) #getting examples of that event type
  plot_events(indices = idxs.event.type[sample(1:length(idxs.event.type),4)], events = events, xs = xs, ys = ys)
}

```

Overall, there are `r length(unique(events$event.type.collapsed))` types of events.

<!-- The most common event type is `r names(event.types.by.freq[1])` -->
<!-- ```{r plotting, echo = FALSE} -->
<!-- plot_events_of_rank(1, event.types.by.freq, events, xs, ys) -->
<!-- ``` -->

<!-- These are events where one moving hyena "passes" a relatively stationary hyena. -->

<!-- ```{r transitions between fission and fusion, echo = FALSE} -->

<!-- idxs.local <- which(events$together.type == 'together.local') -->
<!-- idxs.travel <- which(events$together.type == 'together.travel') -->

<!-- trans.local <- table(events$fission.type[idxs.local], events$fusion.type[idxs.local]) -->
<!-- par(mar = c(12,12,2,2)) -->
<!-- image.plot(trans.local, xaxt = 'n', yaxt = 'n', col = viridis(256)) -->
<!-- axis(side = 1, at = seq(0,1, length.out = nrow(trans.local)), rownames(trans.local), las = 2) -->
<!-- axis(side = 2, at = seq(0,1, length.out = ncol(trans.local)), colnames(trans.local), las = 2) -->
<!-- title(main = 'Transitions for local events') -->


<!-- trans.local <- table(events$fission.type[idxs.travel], events$fusion.type[idxs.travel]) -->
<!-- par(mar = c(12,12,2,2)) -->
<!-- image.plot(trans.local, xaxt = 'n', yaxt = 'n', col = viridis(256)) -->
<!-- axis(side = 1, at = seq(0,1, length.out = nrow(trans.local)), rownames(trans.local), las = 2) -->
<!-- axis(side = 2, at = seq(0,1, length.out = ncol(trans.local)), colnames(trans.local), las = 2) -->
<!-- title(main = 'Transitions for traveling events') -->

<!-- ``` -->


## Event type examples

Let's look at some examples of events of different types.

The most common type is `r names(event.types.by.freq[1])` - there are `r event.types.by.freq[1]` events of this type, meaning it makes up `r round(event.types.by.freq[1] / sum(event.types.by.freq) * 100)`% of all events. We call this type "passing".

```{r, animation.hook="gifski", interval = 0.1, echo = FALSE}
#1-passing
row <- 6
animate_ff_event(event.row = row, events = events, xs = xs, ys = ys)
```

Second most common is `r names(event.types.by.freq[2])` (`r event.types.by.freq[2]` events = `r round(event.types.by.freq[2] / sum(event.types.by.freq) * 100)`%). We call this "displacement".

```{r, animation.hook="gifski", interval = 0.1, echo = FALSE}
#2-displacement type
row <- 64
animate_ff_event(event.row = row, events = events, xs = xs, ys = ys)
```

The bronze medal goes to `r names(event.types.by.freq[3])` (`r event.types.by.freq[3]` events = `r round(event.types.by.freq[3] / sum(event.types.by.freq) * 100)`%). We call this "waking up".

```{r, animation.hook="gifski", interval = 0.1, echo = FALSE}
#3-waking up
row <- 9
animate_ff_event(event.row = row, events = events, xs = xs, ys = ys)
```

Fourth place goes to `r names(event.types.by.freq[4])` (`r event.types.by.freq[4]` events = `r round(event.types.by.freq[4] / sum(event.types.by.freq) * 100)`%). We call this "crossing".

```{r, animation.hook="gifski", interval = 0.1, echo = FALSE}
#4-crossing
row <- 30
animate_ff_event(event.row = row, events = events, xs = xs, ys = ys)
```

All of the most common types of events are "local" events, i.e. the pair does not travel together. In fact, out of all events, only 61 of them (11%) are defined as "traveling" during the together phase, meaning the pair traveled more than 200 m.

Let's have a look at a few of these. First up, there is the most common one (still only 11 events!), fusion.move.move.aligned__together.travel__fission.move.move.aligned. We call this "catching up".

```{r, animation.hook="gifski", interval = 0.1, echo = FALSE}
row <- 16
animate_ff_event(event.row = row, events = events, xs = xs, ys = ys)
```

Here is another type - fusion.stay.move__together.travel__fission.move.move.aligned (10 events) - we call this "picking up".

```{r, animation.hook="gifski", interval = 0.1, echo = FALSE}
#pick up
row <- 36
animate_ff_event(event.row = row, events = events, xs = xs, ys = ys)
```

# Future directions

Looking back at our goals, we feel we have made good headway on the first two:

1. Methodological framework for identifying and measuring fission-fusion events  
2. Taxonomy of basic types of fission-fusion events  

From here, we'd like to work more on the third one:

3. Use this taxonomy to better understand social structure  

Some future directions for our analyses within this project include:

-- Going into more detail on the dynamics of events, including how long hyenas stay together, and how their headings change between the phases  
-- Looking at what types of fission-fusion events occur where (e.g. at the den, etc.) and when (time of day).  
-- Mapping variation in the types of events that occur between different dyads, which perhaps reflects different social relationships.  
-- Mapping variation in the roles individuals play during events, e.g. can we detect asymmetries such as hyena A always approaching hyena B but not the reverse?  
-- Looking more in detail at the "together phase", where a lot of additional complexity arises. For instance, how coordinated are hyenas during this phase, do leader-follower relationships arise, etc.?  


