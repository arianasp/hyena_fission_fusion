---
title: "From fission-fusion events to social structure"
output: html_document
---

In the fission-fusion societies of spotted hyenas, all social interactions 
arise from and are constrained by the coming together or dissolution of individuals. 

Consequently, dyadic fission-fusion events can be considered
the atomic unit of social structure in these societies.  

In this project we want to understand how the mechanics of fission-fusion events 
scale up to broader patterns in social relationships and social structure.    

**Goals:**     
* Methodological framework for identifying and measuring fission-fusion events  
* Taxonomy of basic types of fission-fusion events  
* Use this taxonomy to better understand social structure 

![](https://static.wixstatic.com/media/a3e3e7_bc533d1dfdfc459fa3950b84700830e4~mv2_d_3727_2618_s_4_2.jpg/v1/crop/x_193,y_111,w_3297,h_2366/fill/w_560,h_394,al_c,q_80,usm_0.66_1.00_0.01/a3e3e7_bc533d1dfdfc459fa3950b84700830e4~mv2_d_3727_2618_s_4_2.webp)

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(dichromat)
library(plotly)
library(scales)

# name <- readline(prompt = "Enter name:")
# 
# if(grepl('a|A', name)){
   # basedir <- '~/Dropbox/hyenas/hyena_fission_fusion/' # <-- CHANGE TO THE MAIN PROJECT FOLDER
   # codedir <- '~/Dropbox/code_ari/hyena_fission_fusion/' # <-- CHANGE TO THE DIRECTORY WHERE CODE REPOSITORY IS
# }else if(grepl('e|E', name)){
 basedir <- 'C:/Users/strau/Dropbox/hyena_fission_fusion/' # <-- CHANGE TO THE MAIN PROJECT FOLDER
 codedir <- 'C:/Users/strau/Dropbox/Documents/Research/Partial_projects/hyena_fission_fusion/' # <-- CHANGE TO THE DIRECTORY WHERE CODE REPOSITORY IS
# }else{
#   cat('Name not recognized')
# }

#SUBDIRECTORIES
datadir <- paste(basedir, 'data/raw', sep = '')
processeddir <- paste(basedir, 'data/processed', sep = '') #this is where the output will be saved (the fission fusion events RData file)

#FUNCTIONS
source(paste0(codedir,'/hyena_functions.R'))

#PROCESSED DATA
load(file = paste0(processeddir,'/fission_fusion_features.RData'))
load(file = paste0(processeddir,'/fission_fusion_events.RData'))
load(file = paste0(datadir,'/hyena_xy_level1.RData'))

good.idxs <- which(events$start.exact & events$end.exact)


```

## What is a fission-fusion event?

Fission-fusion events are identified as cases where two individuals get within 100m of each other. 
Once an event is identified, data are collected for the entire duration of the period in which 
they are within 200m of each other. 

This produces `r nrow(events[good.idxs,])` fission-fusion events.

**FIGURE**

Here is some basic exploration of this data

```{r general exploration, echo = FALSE, fig.show= 'hold', out.width = "50%"}


examples <- good.idxs[45:49]

par(mfrow = c(1,1))
plot_events(indices = examples, events = events, xs, ys)
```

## Canonical shape of fission-fusion events

A fundamental measure of dyadic fission fusion events is the distance between
the two individuals ("dyadic distance"). 

Dyadic distance during fission-fusion events has a canonical structure:  
* There is first a decrease in the dyadic distance (as the two hyenas get closer together; "fusion phase")  
* then a relatively stable period where the hyenas spend time close together ("together phase")  
* followed by an increase in the dyadic distance as they part ways ("fission" phase).   

<!-- Our goal is to characterize fission-fusion events and categorize them into a set -->
<!-- of biologically meaningful categories. To do this, we decided to start by looking -->
<!-- at the distance between the pair of individuals over time during each event.  -->

Based on this idea, we decided to fit all fission-fusion events to this canonical 
structure using a 3-part piecewise function. Although the fit isn't always perfect, this approach does
do a reasonable job at capturing the structure of the events.

This allows fission-fusion events to be decomposed into three phases: fission phase, fusion phase, together phase. 

Here are some plots of example events with dyadic distance in black and the fitted 
phases in red. 

```{r plot a single event, echo = FALSE}
par(mfrow = c(1,2))
plot_events(indices = examples[1], events, xs, ys)
plot_canonical_shape(rows = examples[1], dyad.dists = dyad.dists, events)

plot_events(indices = examples[2], events, xs, ys)
plot_canonical_shape(rows = examples[2], dyad.dists, events)

plot_events(indices = examples[3], events, xs, ys)
plot_canonical_shape(rows = examples[3], dyad.dists, events)
```


## Detecting variation in phases of fission-fusion events

We identified two primary variables that capture a lot of variability within phases
of fission-fusion events: 

**Displacement of individuals:** How much did each individual move during the phase?  
**Angle between heading of individuals:** What is the angle in the heading of the two individuals?  


#### Displacement of individuals  

We first looked at the displacement one individual vs the other individual in each of the phases separately.  

Especially in the fission and fusion phases, we see two clear clusters where one 
individual is stationary and the other is moving. We also see a large scattering 
of points representing cases where both individuals are moving substantially. 

```{r plot distance travelled for each individual, echo = FALSE, fig.show = 'hold', out.width = "50%"}

plot(events$disp.fusion.i[good.idxs], events$disp.fusion.j[good.idxs], xlim = c(0,700), ylim = c(0, 700),
     xlab = 'Distance travelled by A', pch = 19, col = scales::alpha('black', 0.3), cex = 0.8, ylab = 'Distance travelled by B', main = 'Fusion phase')

plot(events$disp.together.i[good.idxs], events$disp.together.j[good.idxs], xlim = c(0,700), ylim = c(0, 700),
     xlab = 'Distance travelled by A', pch = 19, col = scales::alpha('black', 0.3), cex = 0.8, ylab = 'Distance travelled by B', main = 'Together phase')

plot(events$disp.fission.i[good.idxs], events$disp.fission.j[good.idxs], xlim = c(0,700), ylim = c(0, 700),
     xlab = 'Distance travelled by A', pch = 19, col = scales::alpha('black', 0.3), cex = 0.8, ylab = 'Distance travelled by B', main = 'Fission phase')


```

#### Angle between heading of individuals

We calculated the angle between the two individuals trajectories, calculated over
the entire phase.  

Including the angle in the plots shows that the angle further resolves some different
types of fission-fusion events, especially in the fission and fusion phases.

```{r plot angle between trajectories of two individuals, echo = FALSE}

min.move <- 50

both.move.fusion <- which(events$disp.fusion.i >= min.move & events$disp.fusion.j >= min.move)
both.move.together <- which(events$disp.together.i >= min.move & events$disp.together.j >= min.move)
both.move.fission <- which(events$disp.fission.i >= min.move & events$disp.fission.j >= min.move)

# hist(events$angle.fusion[both.move.fusion], main = 'Angles during fusion', breaks = 50, xlab = 'Angle (radians)')
# hist(events$angle.together[both.move.together], main = 'Angles during together', breaks = 50, xlab = 'Angle (radians)')
# hist(events$angle.fission[both.move.fission], main = 'Angles during fission', breaks = 50, xlab = 'Angle (radians)')
# 


pal <- colorRampPalette(c('blue', 'black', 'goldenrod1'))
cols <- pal(320)

# Same plots as before but colored by angle
plot(events$disp.fusion.i[good.idxs], events$disp.fusion.j[good.idxs], xlim = c(0,700), ylim = c(0, 700),
     xlab = 'Distance travelled by A', pch = 19, cex = 0.8, ylab = 'Distance travelled by B', main = 'Fusion phase',
     col = alpha(cols[ceiling(events$angle.fusion[good.idxs] * 100)], 0.7))

p <- par()$usr
text(x = p[1] + 0.15*(p[2]-p[1]), y = p[4]- 0.1*(p[4]-p[3]), 'heading unaligned', col = cols[314], adj = 0)
text(x = p[1] + 0.15*(p[2]-p[1]), y = p[4]- 0.15*(p[4]-p[3]), 'heading aligned', col = cols[1], adj = 0)

plot(events$disp.together.i[good.idxs], events$disp.together.j[good.idxs],
     xlab = 'Distance travelled by A', pch = 19, cex = 0.8, ylab = 'Distance travelled by B', main = 'Together phase',
     col = alpha(cols[ceiling(events$angle.together[good.idxs] * 100)], 0.7))
p <- par()$usr
text(x = p[1] + 0.15*(p[2]-p[1]), y = p[4]- 0.1*(p[4]-p[3]), 'heading unaligned', col = cols[314], adj = 0)
text(x = p[1] + 0.15*(p[2]-p[1]), y = p[4]- 0.15*(p[4]-p[3]), 'heading aligned', col = cols[1], adj = 0)

plot(events$disp.together.i[good.idxs], events$disp.together.j[good.idxs], xlim = c(0,200), ylim = c(0,200),
     xlab = 'Distance travelled by A', pch = 19, cex = 0.8, ylab = 'Distance travelled by B', main = 'Together phase (zoomed in)',
     col = alpha(cols[ceiling(events$angle.together[good.idxs] * 100)], 0.7))
p <- par()$usr
text(x = p[1] + 0.15*(p[2]-p[1]), y = p[4]- 0.1*(p[4]-p[3]), 'heading unaligned', col = cols[314], adj = 0)
text(x = p[1] + 0.15*(p[2]-p[1]), y = p[4]- 0.15*(p[4]-p[3]), 'heading aligned', col = cols[1], adj = 0)

plot(events$disp.fission.i[good.idxs], events$disp.fission.j[good.idxs], xlim = c(0,700), ylim = c(0, 700),
     xlab = 'Distance travelled by A', pch = 19, cex = 0.8, ylab = 'Distance travelled by B', main = 'Fission phase',
     col = alpha(cols[ceiling(events$angle.fission[good.idxs] * 100)], 0.7))
p <- par()$usr
text(x = p[1] + 0.15*(p[2]-p[1]), y = p[4]- 0.1*(p[4]-p[3]), 'heading unaligned', col = cols[314], adj = 0)
text(x = p[1] + 0.15*(p[2]-p[1]), y = p[4]- 0.15*(p[4]-p[3]), 'heading aligned', col = cols[1], adj = 0)

```
```{r phases to categories, echo = FALSE}
#thresholds
move.thresh <- 5
ang.thresh <- pi/2

#defining clusters - fusion
fusion.stay.move.idxs <- which(events$disp.fusion.i <= move.thresh)
fusion.move.stay.idxs <- which(events$disp.fusion.j <= move.thresh)
fusion.move.move.bigang.idxs <- which(events$disp.fusion.i > move.thresh & events$disp.fusion.j > move.thresh & events$angle.fusion > ang.thresh)
fusion.move.move.smallang.idxs <- which(events$disp.fusion.i > move.thresh & events$disp.fusion.j > move.thresh & events$angle.fusion <= ang.thresh)

#defining clusters - together
together.stay.stay.idxs <- which(events$disp.together.i <= move.thresh & events$disp.together.j <= move.thresh)
together.stay.move.idxs <- which(events$disp.together.i <= move.thresh & events$disp.together.j > move.thresh)
together.move.stay.idxs <- which(events$disp.together.j <= move.thresh & events$disp.together.i > move.thresh)
together.move.move.idxs <- which(events$disp.together.i > move.thresh & events$disp.together.j > move.thresh)

#defining clusters - fission
fission.stay.move.idxs <- which(events$disp.fission.i <= move.thresh)
fission.move.stay.idxs <- which(events$disp.fission.j <= move.thresh)
fission.move.move.bigang.idxs <- which(events$disp.fission.i > move.thresh & events$disp.fission.j > move.thresh & events$angle.fission > ang.thresh)
fission.move.move.smallang.idxs <- which(events$disp.fission.i > move.thresh & events$disp.fission.j > move.thresh & events$angle.fission <= ang.thresh)

#store clusters in events data frame
events$fusion.type <- events$together.type <- events$fission.type <- NA
events$fusion.type[fusion.stay.move.idxs] <- 'fusion.stay.move'
events$fusion.type[fusion.move.stay.idxs] <- 'fusion.move.stay'
events$fusion.type[fusion.move.move.bigang.idxs] <- 'fusion.move.move.bigang'
events$fusion.type[fusion.move.move.smallang.idxs] <- 'fusion.move.move.smallang'
events$together.type[together.stay.stay.idxs] <- 'together.stay.stay'
events$together.type[together.stay.move.idxs] <- 'together.stay.move'
events$together.type[together.move.stay.idxs] <- 'together.move.stay'
events$together.type[together.move.move.idxs] <- 'together.move.move'
events$fission.type[fission.stay.move.idxs] <- 'fission.stay.move'
events$fission.type[fission.move.stay.idxs] <- 'fission.move.stay'
events$fission.type[fission.move.move.bigang.idxs] <- 'fission.move.move.bigang'
events$fission.type[fission.move.move.smallang.idxs] <- 'fission.move.move.smallang'

#look at what types emerge
complete.events <- which(!(is.na(events$fusion.type) | is.na(events$together.type) | is.na(events$fission.type)))
events$event.type <- paste(events$fusion.type, events$together.type, events$fission.type, sep = '__')

```

## Taxonomy of fission-fusion events using phase measurements

Next we broke phases into a set of discrete categories.

For all 3 phases, we divided events into categories based on the movement of individuals.  

We chose a **movement threshold** of `r move.thresh` to classify each individual as moving or not moving. 
We chose an **angle threshold** of `r ang.thresh/pi * 180/pi` degrees to classify individuals as having
aligned or opposite movement trajectories.

We identified the following categories: 

**Fusion phase (4)**
1. Individual A moving, Individual B stationary    
2. Individual A stationary, Individual B moving  
3. Both moving, trajectories aligned  
4. Both moving, trajectories unaligned  

**Together phase (4)**
1. Individual A moving, Individual B stationary  
2. Individual A stationary, Individual B moving  
3. Both moving  
4. Both staying  

**Fission phase (4)**
1. Individual A moving, Individual B stationary  
2. Individual A stationary, Individual B moving  
3. Both moving, trajectories aligned  
4. Both moving, trajectories unaligned  


```{r plotting phase categories, echo = FALSE, message = FALSE}

fusion.cols <- c('#33658A', '#86BBD8', '#758E4F', '#F26419')
together.cols <- c('#210124', '#750D37', '#9CD3AE', '#0C4634')


#3d plot
aX <- list(title = "Distance travelled by A (m)", range = c(0,700))
aY <- list(title = "Distance travelled by B (m)", range = c(0,700))
aZ <- list(title = 'Angle (degrees)', range = c(0, 210))
plot_ly(x = events$disp.together.i[good.idxs], y = events$disp.together.j[good.idxs], z = events$angle.together[good.idxs]*180/pi, type = 'scatter3d', mode = 'markers', size = 0.5,
        color = as.factor(events$together.type[good.idxs]), colors = together.cols) %>%
   layout(scene = list(xaxis = aX, yaxis = aY, zaxis = aZ, dragmode="turntable"))


aX <- list(title = "Distance travelled by A (m)", range = c(0,700))
aY <- list(title = "Distance travelled by B (m)", range = c(0,700))
aZ <- list(title = 'Angle (degrees)', range = c(0, 210))
plot_ly(x = events$disp.fusion.i[good.idxs], y = events$disp.fusion.j[good.idxs], z = events$angle.fusion[good.idxs]*180/pi, type = 'scatter3d', mode = 'markers', size = 0.5,
        color = as.factor(events$fusion.type[good.idxs]), colors = fusion.cols) %>%
   layout(scene = list(xaxis = aX, yaxis = aY, zaxis = aZ, dragmode="turntable"))

#2d plot
cols <- c('red','blue','green','black','gray')
fusion.event.types <- unique(events$fusion.type)
plot(events$disp.fusion.i[good.idxs], events$disp.fusion.j[good.idxs], xlim = c(0,700), ylim = c(0, 700),
     xlab = 'Distance travelled by A', pch = 19, cex = 0.8, ylab = 'Distance travelled by B', main = 'Fusion phase',
     col = fusion.cols[as.factor(events$fusion.type[good.idxs])])

```

Now that we have a taxonomy of event types, let's have a look at some common ones and hypothesize about what's going on (give them names).

```{r code to plot examples of an event of a certain rank, echo = FALSE}

event.types.by.freq <- sort(table(events$event.type[complete.events]), decreasing = T)

plot_events_of_rank <- function(event.rank, event.types.by.freq = event.types.by.freq, events = events, xs = xs, ys = ys){

  idxs.event.type <- which(events$event.type == names(event.types.by.freq[event.rank])) #getting examples of that event type
  plot_events(indices = idxs.event.type[sample(1:length(idxs.event.type),4)], events = events, xs = xs, ys = ys)
}

```
The most common event type is `r names(event.types.by.freq[1])`
```{r plotting, echo = FALSE}
plot_events_of_rank(1, event.types.by.freq, events, xs, ys)
```

These are events where two moving hyenas meeting each other at a small angle, then move together for a bit (possibly very short bit) and finally split at a small angle. These would include instances where hyenas meet up, move together, and then diverge, or could also be crossover events occurring at small angles.
